/* Generated by Nelua 0.2.0-dev */
/* Compile command: gcc -x c "coutput/zlnl.c" -x none -o "coutput/zlnl" -fwrapv -Ofast -march=native -DNDEBUG -fno-plt -flto -lSDL2 -lm */
/* Compile hash: 4RERwdvCxLKx65hMJRMvzut4nzER */
/* ------------------------------ DIRECTIVES -------------------------------- */
/* Disable some warnings that the generated code can trigger. */
#if defined(__clang__)
  #pragma clang diagnostic ignored "-Wtype-limits"
  #pragma clang diagnostic ignored "-Wwrite-strings"
  #pragma clang diagnostic ignored "-Wunused"
  #pragma clang diagnostic ignored "-Wunused-parameter"
  #pragma clang diagnostic ignored "-Wmissing-field-initializers"
  #pragma clang diagnostic ignored "-Wparentheses-equality"
  #ifndef __cplusplus
    #pragma clang diagnostic ignored "-Wmissing-braces"
    #pragma clang diagnostic ignored "-Wincompatible-pointer-types"
    #pragma clang diagnostic error   "-Wimplicit-function-declaration"
    #pragma clang diagnostic error   "-Wimplicit-int"
  #else
    #pragma clang diagnostic ignored "-Wnarrowing"
  #endif
#elif defined(__GNUC__)
  #pragma GCC diagnostic ignored "-Wtype-limits"
  #pragma GCC diagnostic ignored "-Wwrite-strings"
  #pragma GCC diagnostic ignored "-Wunused-parameter"
  #pragma GCC diagnostic ignored "-Wunused-value"
  #pragma GCC diagnostic ignored "-Wunused-variable"
  #pragma GCC diagnostic ignored "-Wunused-function"
  #pragma GCC diagnostic ignored "-Wunused-but-set-variable"
  #pragma GCC diagnostic ignored "-Wmissing-field-initializers"
  #ifndef __cplusplus
    #pragma GCC diagnostic ignored "-Wmissing-braces"
    #pragma GCC diagnostic ignored "-Wincompatible-pointer-types"
    #pragma GCC diagnostic ignored "-Wdiscarded-qualifiers"
    #pragma GCC diagnostic error   "-Wimplicit-function-declaration"
    #pragma GCC diagnostic error   "-Wimplicit-int"
  #else
    #pragma GCC diagnostic ignored "-Wnarrowing"
  #endif
#endif
#if defined(_WIN32) && !defined(_CRT_SECURE_NO_WARNINGS)
  #define _CRT_SECURE_NO_WARNINGS
#endif
/* Macro used to perform compile-time checks. */
#if __STDC_VERSION__ >= 201112L
  #define NELUA_STATIC_ASSERT _Static_assert
#elif __cplusplus >= 201103L
  #define NELUA_STATIC_ASSERT static_assert
#else
  #define NELUA_STATIC_ASSERT(x, y)
#endif
/* Macro used to get alignment of a type. */
#if __STDC_VERSION__ >= 201112L
  #define NELUA_ALIGNOF _Alignof
#elif __cplusplus >= 201103L
  #define NELUA_ALIGNOF alignof
#elif defined(__GNUC__)
  #define NELUA_ALIGNOF __alignof__
#elif defined(_MSC_VER)
  #define NELUA_ALIGNOF __alignof
#else
  #define NELUA_ALIGNOF(x)
#endif
/* Checks if Nelua and C agrees on pointer size. */
NELUA_STATIC_ASSERT(sizeof(void*) == 8 && NELUA_ALIGNOF(void*) == 8, "Nelua and C disagree on pointer size or alignment");
/* Enable 64 bit offsets for stdio APIs. */
#if !defined(_FILE_OFFSET_BITS) && __SIZEOF_LONG__ >= 8
  #define _FILE_OFFSET_BITS 64
#endif
/* Enable POSIX APIs in included headers. */
#if !defined(_POSIX_C_SOURCE) && !defined(_XOPEN_SOURCE) && !defined(_GNU_SOURCE) && !defined(_DEFAULT_SOURCE)
  #if defined(__gnu_linux__)
    #define _GNU_SOURCE
  #else
    #define _XOPEN_SOURCE 600
  #endif
#endif
#define SDL_MAIN_HANDLED
#include <SDL2/SDL_opengl.h>
#include <SDL2/SDL.h>
#include <tinyfx.h>
#include <math_extra.h>
#include <stdint.h>
/* Macro used to force inlining a function. */
#ifdef __GNUC__
  #define NELUA_INLINE __attribute__((always_inline)) inline
#elif defined(_MSC_VER)
  #define NELUA_NOINLINE __forceinline
#elif __STDC_VERSION__ >= 199901L
  #define NELUA_INLINE inline
#else
  #define NELUA_INLINE
#endif
/* Macro used for branch prediction. */
#if defined(__GNUC__) || defined(__clang__)
  #define NELUA_LIKELY(x) __builtin_expect(x, 1)
#else
  #define NELUA_LIKELY(x) (x)
#endif
/* Macro used for branch prediction. */
#if defined(__GNUC__) || defined(__clang__)
  #define NELUA_UNLIKELY(x) __builtin_expect(x, 0)
#else
  #define NELUA_UNLIKELY(x) (x)
#endif
#include <stdbool.h>
#include <stddef.h>
#include <string.h>
#include <stdlib.h>
#define NELUA_NIL (nlniltype){}
#include <stdio.h>
/* Macro used to import/export extern C functions. */
#ifdef __cplusplus
  #define NELUA_EXTERN extern "C"
#else
  #define NELUA_EXTERN extern
#endif
/* Macro used to generate traceback on aborts when sanitizing. */
#if defined(__clang__) && defined(__has_feature)
  #if __has_feature(undefined_behavior_sanitizer)
    #define NELUA_UBSAN_UNREACHABLE __builtin_unreachable
  #endif
#elif defined(__GNUC__) && !defined(_WIN32)
  NELUA_EXTERN void __ubsan_handle_builtin_unreachable(void*) __attribute__((weak));
  #define NELUA_UBSAN_UNREACHABLE() {if(&__ubsan_handle_builtin_unreachable) __builtin_unreachable();}
#endif
#ifndef NELUA_UBSAN_UNREACHABLE
  #define NELUA_UBSAN_UNREACHABLE()
#endif
/* Macro used to specify a function that never returns. */
#if __STDC_VERSION__ >= 201112L
  #define NELUA_NORETURN _Noreturn
#elif defined(__GNUC__)
  #define NELUA_NORETURN __attribute__((noreturn))
#elif defined(_MSC_VER)
  #define NELUA_NORETURN __declspec(noreturn)
#else
  #define NELUA_NORETURN
#endif
/* Macro used to force not inlining a function. */
#ifdef __GNUC__
  #define NELUA_NOINLINE __attribute__((noinline))
#elif defined(_MSC_VER)
  #define NELUA_NOINLINE __declspec(noinline)
#else
  #define NELUA_NOINLINE
#endif
/* Macro used suppress sanitizer errors when the GC is scanning. */
#if defined(__has_feature)
  #if __has_feature(address_sanitizer)
    #define NELUA_GC_NO_SANITIZE __attribute__((no_sanitize_address))
  #elif __has_feature(memory_sanitizer)
    #define NELUA_GC_NO_SANITIZE __attribute__((no_sanitize_memory))
  #endif
#endif
#ifndef NELUA_GC_NO_SANITIZE
  #if defined(__SANITIZE_ADDRESS__)
    #define NELUA_GC_NO_SANITIZE __attribute__((no_sanitize_address))
  #else
    #define NELUA_GC_NO_SANITIZE
  #endif
#endif
#include <setjmp.h>
#include <time.h>
/* ------------------------------ DECLARATIONS ------------------------------ */
static NELUA_INLINE uint64_t nelua_rotl(uint64_t x, int32_t n);
static NELUA_INLINE uint64_t nelua_shl_nluint64(uint64_t a, int64_t b);
static NELUA_INLINE uint64_t nelua_shr_nluint64(uint64_t a, int64_t b);
typedef struct nelua_Xoshiro256 nelua_Xoshiro256;
typedef nelua_Xoshiro256* nelua_Xoshiro256_ptr;
struct nelua_Xoshiro256 {
  uint64_t state[4];
};
NELUA_STATIC_ASSERT(sizeof(nelua_Xoshiro256) == 32 && NELUA_ALIGNOF(nelua_Xoshiro256) == 8, "Nelua and C disagree on type size or align");
static NELUA_INLINE uint64_t nelua_Xoshiro256_nextrand(nelua_Xoshiro256_ptr self);
typedef struct nluint64_arr4 {uint64_t v[4];} nluint64_arr4;
NELUA_STATIC_ASSERT(sizeof(nluint64_arr4) == 32 && NELUA_ALIGNOF(nluint64_arr4) == 8, "Nelua and C disagree on type size or align");
static double nelua_Xoshiro256_random(nelua_Xoshiro256_ptr self);
static void nelua_Xoshiro256_seed(nelua_Xoshiro256_ptr self, uint64_t a, uint64_t b);
static nelua_Xoshiro256 nelua_default_random = {.state = {0x65ce039baebe74b4ULL, 0x4911ada153b51eefULL, 0xfb71fbb497c00950ULL, 0xf83ccf6ac1b74755ULL}};
typedef struct nlmulret_nlint64_nlint64 {
  int64_t r1;
  int64_t r2;
} nlmulret_nlint64_nlint64;
typedef struct nlniltype {} nlniltype;
static nlmulret_nlint64_nlint64 nelua_math_randomseed_1(int64_t x, nlniltype y);
static int64_t nelua_math_random_1(int64_t m, int n);
static int64_t nelua_math_random_2(int64_t m, int64_t n);
typedef struct main_entity main_entity;
typedef main_entity* main_entity_ptr;
typedef struct nlmulret_nlboolean_nlint64_main_entity_ptr {
  bool r1;
  int64_t r2;
  main_entity_ptr r3;
} nlmulret_nlboolean_nlint64_main_entity_ptr;
struct main_entity {
  double x;
  double y;
  double vx;
  double vy;
};
NELUA_STATIC_ASSERT(sizeof(main_entity) == 32 && NELUA_ALIGNOF(main_entity) == 8, "Nelua and C disagree on type size or align");
typedef struct main_entity_arr101 {main_entity v[101];} main_entity_arr101;
NELUA_STATIC_ASSERT(sizeof(main_entity_arr101) == 3232 && NELUA_ALIGNOF(main_entity_arr101) == 8, "Nelua and C disagree on type size or align");
typedef main_entity_arr101* main_entity_arr101_ptr;
typedef nlmulret_nlboolean_nlint64_main_entity_ptr (*function_3KD4K8avoExANbbuQ)(main_entity_arr101_ptr, int64_t);
typedef struct nlmulret_function_3KD4K8avoExANbbuQ_main_entity_arr101_ptr_nlint64 {
  function_3KD4K8avoExANbbuQ r1;
  main_entity_arr101_ptr r2;
  int64_t r3;
} nlmulret_function_3KD4K8avoExANbbuQ_main_entity_arr101_ptr_nlint64;
static NELUA_INLINE nlmulret_function_3KD4K8avoExANbbuQ_main_entity_arr101_ptr_nlint64 nelua_mipairs_1(main_entity_arr101_ptr a);
static NELUA_INLINE nlmulret_nlboolean_nlint64_main_entity_ptr nelua_mipairs_next(main_entity_arr101_ptr a_1, int64_t k);
typedef struct nelua_GCItem nelua_GCItem;
typedef nelua_GCItem* nelua_GCItem_ptr;
typedef struct nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr {
  bool r1;
  void* r2;
  nelua_GCItem_ptr r3;
} nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr;
typedef struct nelua_hashmap_iteratorT nelua_hashmap_iteratorT;
typedef nelua_hashmap_iteratorT* nelua_hashmap_iteratorT_ptr;
typedef nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr (*function_2aArm761WFweS6BxH)(nelua_hashmap_iteratorT_ptr, void*);
typedef struct nelua_hashmap_pointer__GCItem_ nelua_hashmap_pointer__GCItem_;
typedef nelua_hashmap_pointer__GCItem_* nelua_hashmap_pointer__GCItem__ptr;
struct nelua_hashmap_iteratorT {
  nelua_hashmap_pointer__GCItem__ptr container;
  uintptr_t index;
};
NELUA_STATIC_ASSERT(sizeof(nelua_hashmap_iteratorT) == 16 && NELUA_ALIGNOF(nelua_hashmap_iteratorT) == 8, "Nelua and C disagree on type size or align");
typedef struct nelua_span_usize_ nelua_span_usize_;
typedef uintptr_t* nlusize_arr0_ptr;
struct nelua_span_usize_ {
  nlusize_arr0_ptr data;
  uintptr_t size;
};
NELUA_STATIC_ASSERT(sizeof(nelua_span_usize_) == 16 && NELUA_ALIGNOF(nelua_span_usize_) == 8, "Nelua and C disagree on type size or align");
typedef struct nelua_span_hashmapnode_pointer__GCItem__ nelua_span_hashmapnode_pointer__GCItem__;
typedef struct nelua_hashmapnode_pointer__GCItem_ nelua_hashmapnode_pointer__GCItem_;
typedef nelua_hashmapnode_pointer__GCItem_* nelua_hashmapnode_pointer__GCItem__arr0_ptr;
struct nelua_span_hashmapnode_pointer__GCItem__ {
  nelua_hashmapnode_pointer__GCItem__arr0_ptr data;
  uintptr_t size;
};
NELUA_STATIC_ASSERT(sizeof(nelua_span_hashmapnode_pointer__GCItem__) == 16 && NELUA_ALIGNOF(nelua_span_hashmapnode_pointer__GCItem__) == 8, "Nelua and C disagree on type size or align");
typedef struct nelua_GeneralAllocator nelua_GeneralAllocator;
struct nelua_GeneralAllocator {};
struct nelua_hashmap_pointer__GCItem_ {
  nelua_span_usize_ buckets;
  nelua_span_hashmapnode_pointer__GCItem__ nodes;
  uintptr_t size;
  uintptr_t free_index;
  nelua_GeneralAllocator allocator;
};
NELUA_STATIC_ASSERT(sizeof(nelua_hashmap_pointer__GCItem_) == 48 && NELUA_ALIGNOF(nelua_hashmap_pointer__GCItem_) == 8, "Nelua and C disagree on type size or align");
typedef void (*nelua_GCFinalizerCallback)(void*, void*);
struct nelua_GCItem {
  uintptr_t flags;
  uintptr_t size;
  void* ptr;
  nelua_GCFinalizerCallback finalizer;
  void* userdata;
};
NELUA_STATIC_ASSERT(sizeof(nelua_GCItem) == 40 && NELUA_ALIGNOF(nelua_GCItem) == 8, "Nelua and C disagree on type size or align");
struct nelua_hashmapnode_pointer__GCItem_ {
  void* key;
  nelua_GCItem value;
  bool filled;
  uintptr_t next;
};
NELUA_STATIC_ASSERT(sizeof(nelua_hashmapnode_pointer__GCItem_) == 64 && NELUA_ALIGNOF(nelua_hashmapnode_pointer__GCItem_) == 8, "Nelua and C disagree on type size or align");
typedef struct nlmulret_function_2aArm761WFweS6BxH_nelua_hashmap_iteratorT_nlpointer {
  function_2aArm761WFweS6BxH r1;
  nelua_hashmap_iteratorT r2;
  void* r3;
} nlmulret_function_2aArm761WFweS6BxH_nelua_hashmap_iteratorT_nlpointer;
static NELUA_INLINE nlmulret_function_2aArm761WFweS6BxH_nelua_hashmap_iteratorT_nlpointer nelua_mpairs_1(nelua_hashmap_pointer__GCItem__ptr a);
static NELUA_INLINE mat4 libs_math_extra_mat4_new(void);
static mat4 libs_math_extra_tmp;
typedef mat4* mat4_ptr;
static NELUA_INLINE void libs_math_extra_mat4_identity(mat4_ptr a);
typedef struct nlfloat32_arr16 {float v[16];} nlfloat32_arr16;
NELUA_STATIC_ASSERT(sizeof(nlfloat32_arr16) == 64 && NELUA_ALIGNOF(nlfloat32_arr16) == 4, "Nelua and C disagree on type size or align");
static NELUA_INLINE mat4 libs_math_extra_mat4_from_ortho(double left, double right, double top, double bottom, double near, double far);
static NELUA_INLINE mat4 libs_math_extra_mat4___mul(mat4 a, mat4 b);
typedef struct libs_math_extra_vec3 libs_math_extra_vec3;
struct libs_math_extra_vec3 {
  double x;
  double y;
  double z;
};
NELUA_STATIC_ASSERT(sizeof(libs_math_extra_vec3) == 24 && NELUA_ALIGNOF(libs_math_extra_vec3) == 8, "Nelua and C disagree on type size or align");
static NELUA_INLINE mat4 libs_math_extra_mat4_translate(mat4 a, libs_math_extra_vec3 b);
static NELUA_INLINE mat4 libs_math_extra_mat4_scale(mat4 a, libs_math_extra_vec3 b);
static NELUA_INLINE void nelua_memory_zero(void* dest, uintptr_t n);
typedef void** nlpointer_ptr;
typedef struct nelua_span_pointer_ nelua_span_pointer_;
typedef nelua_span_pointer_* nelua_span_pointer__ptr;
typedef void** nlpointer_arr0_ptr;
struct nelua_span_pointer_ {
  nlpointer_arr0_ptr data;
  uintptr_t size;
};
NELUA_STATIC_ASSERT(sizeof(nelua_span_pointer_) == 16 && NELUA_ALIGNOF(nelua_span_pointer_) == 8, "Nelua and C disagree on type size or align");
static NELUA_INLINE nlpointer_ptr nelua_span_pointer____atindex(nelua_span_pointer__ptr self, uintptr_t i);
typedef uintptr_t* nlusize_ptr;
typedef nelua_span_usize_* nelua_span_usize__ptr;
static NELUA_INLINE nlusize_ptr nelua_span_usize____atindex(nelua_span_usize__ptr self, uintptr_t i);
typedef nelua_hashmapnode_pointer__GCItem_* nelua_hashmapnode_pointer__GCItem__ptr;
typedef nelua_span_hashmapnode_pointer__GCItem__* nelua_span_hashmapnode_pointer__GCItem___ptr;
static NELUA_INLINE nelua_hashmapnode_pointer__GCItem__ptr nelua_span_hashmapnode_pointer__GCItem_____atindex(nelua_span_hashmapnode_pointer__GCItem___ptr self, uintptr_t i);
static NELUA_INLINE void nelua_memory_spanset_1(nelua_span_usize_ dest, uintptr_t x);
static nelua_GeneralAllocator nelua_general_allocator;
typedef nelua_GeneralAllocator* nelua_GeneralAllocator_ptr;
static NELUA_INLINE void* nelua_GeneralAllocator_alloc(nelua_GeneralAllocator_ptr self, uintptr_t size);
static NELUA_INLINE void* nelua_GeneralAllocator_alloc0(nelua_GeneralAllocator_ptr self, uintptr_t size);
static NELUA_INLINE void nelua_GeneralAllocator_dealloc(nelua_GeneralAllocator_ptr self, void* p);
static NELUA_INLINE void* nelua_GeneralAllocator_realloc(nelua_GeneralAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize);
static void* nelua_GeneralAllocator_realloc0(nelua_GeneralAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize);
typedef uint8_t* nluint8_arr0_ptr;
static nelua_span_pointer_ nelua_GeneralAllocator_spanalloc_1(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size);
static nelua_span_usize_ nelua_GeneralAllocator_spanalloc_2(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size);
static nelua_span_hashmapnode_pointer__GCItem__ nelua_GeneralAllocator_spanalloc0_1(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size);
static void nelua_GeneralAllocator_spandealloc_1(nelua_GeneralAllocator_ptr self, nelua_span_pointer_ s);
static void nelua_GeneralAllocator_spandealloc_2(nelua_GeneralAllocator_ptr self, nelua_span_usize_ s);
static void nelua_GeneralAllocator_spandealloc_3(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_pointer__GCItem__ s);
static nelua_span_pointer_ nelua_GeneralAllocator_spanrealloc_1(nelua_GeneralAllocator_ptr self, nelua_span_pointer_ s, uintptr_t size);
static nelua_span_usize_ nelua_GeneralAllocator_spanrealloc_2(nelua_GeneralAllocator_ptr self, nelua_span_usize_ s, uintptr_t size);
static nelua_span_pointer_ nelua_GeneralAllocator_xspanrealloc_1(nelua_GeneralAllocator_ptr self, nelua_span_pointer_ s, uintptr_t size);
static NELUA_NORETURN void nelua_abort(void);
typedef struct nlstring nlstring;
struct nlstring {
  nluint8_arr0_ptr data;
  uintptr_t size;
};
NELUA_STATIC_ASSERT(sizeof(nlstring) == 16 && NELUA_ALIGNOF(nlstring) == 8, "Nelua and C disagree on type size or align");
static NELUA_NORETURN void nelua_panic_string(nlstring s);
static nelua_span_usize_ nelua_GeneralAllocator_xspanrealloc_2(nelua_GeneralAllocator_ptr self, nelua_span_usize_ s, uintptr_t size);
static nelua_span_hashmapnode_pointer__GCItem__ nelua_GeneralAllocator_spanrealloc0_1(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_pointer__GCItem__ s, uintptr_t size);
static nelua_span_hashmapnode_pointer__GCItem__ nelua_GeneralAllocator_xspanrealloc0_1(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_pointer__GCItem__ s, uintptr_t size);
static uintptr_t nelua_hash_hash_1(void* v);
static NELUA_INLINE uintptr_t nelua_ceilidiv(uintptr_t x, uintptr_t y);
static NELUA_INLINE uintptr_t nelua_hashmod(uintptr_t h, uintptr_t n);
static NELUA_INLINE uintptr_t nelua_roundpow2(uintptr_t n);
static void nelua_hashmap_pointer__GCItem__destroy(nelua_hashmap_pointer__GCItem__ptr self);
typedef struct nlmulret_nlusize_nlusize_nlusize {
  uintptr_t r1;
  uintptr_t r2;
  uintptr_t r3;
} nlmulret_nlusize_nlusize_nlusize;
static NELUA_INLINE nlmulret_nlusize_nlusize_nlusize nelua_hashmap_pointer__GCItem___find(nelua_hashmap_pointer__GCItem__ptr self, void* key);
static NELUA_NOINLINE void nelua_hashmap_pointer__GCItem__rehash(nelua_hashmap_pointer__GCItem__ptr self, uintptr_t bucket_count);
static uintptr_t nelua_hashmap_pointer__GCItem___at(nelua_hashmap_pointer__GCItem__ptr self, void* key);
static nelua_GCItem_ptr nelua_hashmap_pointer__GCItem____atindex(nelua_hashmap_pointer__GCItem__ptr self, void* key);
static nelua_GCItem_ptr nelua_hashmap_pointer__GCItem__peek(nelua_hashmap_pointer__GCItem__ptr self, void* key);
static nelua_GCItem nelua_hashmap_pointer__GCItem__remove(nelua_hashmap_pointer__GCItem__ptr self, void* key);
static uintptr_t nelua_hashmap_pointer__GCItem__bucketcount(nelua_hashmap_pointer__GCItem__ptr self);
static NELUA_INLINE nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr nelua_hashmap_iteratorT_mnext(nelua_hashmap_iteratorT_ptr self, void* key);
static NELUA_INLINE nlmulret_function_2aArm761WFweS6BxH_nelua_hashmap_iteratorT_nlpointer nelua_hashmap_pointer__GCItem____mpairs(nelua_hashmap_pointer__GCItem__ptr self);
typedef struct nelua_vector_pointer_ nelua_vector_pointer_;
typedef nelua_vector_pointer_* nelua_vector_pointer__ptr;
struct nelua_vector_pointer_ {
  nelua_span_pointer_ data;
  uintptr_t size;
  nelua_GeneralAllocator allocator;
};
NELUA_STATIC_ASSERT(sizeof(nelua_vector_pointer_) == 24 && NELUA_ALIGNOF(nelua_vector_pointer_) == 8, "Nelua and C disagree on type size or align");
static void nelua_vector_pointer__clear(nelua_vector_pointer__ptr self);
static void nelua_vector_pointer__destroy(nelua_vector_pointer__ptr self);
static NELUA_NOINLINE void nelua_vectorT_grow(nelua_vector_pointer__ptr self);
static void nelua_vector_pointer__push(nelua_vector_pointer__ptr self, void* v);
static NELUA_INLINE nlpointer_ptr nelua_vector_pointer____atindex(nelua_vector_pointer__ptr self, uintptr_t pos);
static NELUA_INLINE bool nelua_hasflag(uintptr_t flags, uintptr_t flag);
static NELUA_INLINE bool nelua_GCItem_ismarked(nelua_GCItem_ptr self);
typedef struct nelua_GC nelua_GC;
struct nelua_GC {
  bool running;
  bool collecting;
  uintptr_t pause;
  uintptr_t membytes;
  uintptr_t lastmembytes;
  uintptr_t minaddr;
  uintptr_t maxaddr;
  void* stackbottom;
  nelua_vector_pointer_ frees;
  nelua_hashmap_pointer__GCItem_ items;
};
NELUA_STATIC_ASSERT(sizeof(nelua_GC) == 128 && NELUA_ALIGNOF(nelua_GC) == 8, "Nelua and C disagree on type size or align");
static nelua_GC nelua_gc;
typedef nelua_GC* nelua_GC_ptr;
static NELUA_GC_NO_SANITIZE void nelua_GC_markptrs(nelua_GC_ptr self, uintptr_t low, uintptr_t high);
static NELUA_NOINLINE void nelua_GC_unmarkall(nelua_GC_ptr self);
static NELUA_NOINLINE void nelua_GC_markroot(nelua_GC_ptr self);
static NELUA_NOINLINE void nelua_GC_markstackinner(nelua_GC_ptr self);
static NELUA_NOINLINE void nelua_GC_markstack(nelua_GC_ptr self);
typedef void (*function_42YwF3raoDCqXkrMb)(nelua_GC_ptr);
static void nelua_GC_mark(nelua_GC_ptr self);
static NELUA_NOINLINE void nelua_GC_sweep(nelua_GC_ptr self);
static void nelua_GC_collect(nelua_GC_ptr self);
static void nelua_GC_registerroots(nelua_GC_ptr self);
typedef void (*function_3SCL8hZZUmGrg3Fpt)(void*, void*);
static void nelua_GC_maybecollect(nelua_GC_ptr self);
static void nelua_GC_register(nelua_GC_ptr self, void* ptr, uintptr_t size, uintptr_t flags, function_3SCL8hZZUmGrg3Fpt finalizer, void* userdata);
static void nelua_GC_restart(nelua_GC_ptr self);
static void nelua_GC_init(nelua_GC_ptr self, void* stack);
static void nelua_GC_destroy(nelua_GC_ptr self);
typedef char** nlcstring_ptr;
int main(int argc, nlcstring_ptr argv);
typedef int (*function_whyVgXTXPjxLVKu7)(int, nlcstring_ptr);
static int64_t nelua_os_time_1(nlniltype desc);
typedef time_t* nlctime_t_ptr;
static void nelua_assert_line_1(bool cond, nlstring msg);
typedef SDL_Window* SDL_Window_ptr;
static SDL_Window_ptr main_window;
static void* main_context;
static int main_g_width = 0;
static int main_g_height = 0;
static int64_t main_back = 0;
typedef struct nlcstring_arr2 {char* v[2];} nlcstring_arr2;
NELUA_STATIC_ASSERT(sizeof(nlcstring_arr2) == 16 && NELUA_ALIGNOF(nlcstring_arr2) == 8, "Nelua and C disagree on type size or align");
static nlcstring_arr2 main_attribs = {.v = {"a_position", "a_texCoord"}};
static unsigned int main_program;
static NELUA_INLINE char* nelua_string2cstring(nlstring s);
static char nelua_strlit_1[794] = "#ifdef VERTEX \n    in vec3 a_position;\n    in vec2 a_texCoord;\n\n    out vec2 TexCoords;\n\n    uniform mat4 model;\n    uniform mat4 projection;\n\n    void main()\n    {\n        TexCoords = a_texCoord;\n        gl_Position = projection * model * vec4(a_position, 1.0);\n    }\n#endif\n\n#ifdef PIXEL\n    precision mediump float;\n    in vec2 TexCoords;\n    out vec4 out_color;\n\n    uniform sampler2D image;\n    uniform vec4 mainColor;\n\n    uniform vec4 dark;\n    uniform vec4 light;\n    uniform float intensity;\n    uniform float amount;\n\n    void main()\n    {    \n        vec4 c = mainColor;// * texture(image, TexCoords);\n        float cluma = 1.-dot(c.rgb, vec3(0.299, 0.587, 0.114));\n        vec4 o = mix(dark, light, 1.-(cluma*intensity)); //  \n        out_color = mix(c, o, amount);\n    }  \n#endif\n";
typedef char** nlcstring_arr0_ptr;
typedef struct nlfloat32_arr30 {float v[30];} nlfloat32_arr30;
NELUA_STATIC_ASSERT(sizeof(nlfloat32_arr30) == 120 && NELUA_ALIGNOF(nlfloat32_arr30) == 4, "Nelua and C disagree on type size or align");
static nlfloat32_arr30 main_verts = {.v = {0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f, 0.0f, 1.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f}};
static tfx_vertex_format main_fmt;
static tfx_buffer main_vbo;
typedef float* nlfloat32_arr0_ptr;
static mat4 main_projection;
static tfx_uniform main_projectionUniform;
static mat4 main_model;
static tfx_uniform main_modelUniform;
static tfx_uniform main_colorUniform;
typedef struct nlfloat32_arr4 {float v[4];} nlfloat32_arr4;
NELUA_STATIC_ASSERT(sizeof(nlfloat32_arr4) == 16 && NELUA_ALIGNOF(nlfloat32_arr4) == 4, "Nelua and C disagree on type size or align");
static nlfloat32_arr4 main_color = {.v = {1.0f, 1.0f, 1.0f, 1.0f}};
static tfx_uniform main_lightUniform;
static nlfloat32_arr4 main_light = {.v = {1.0f, 0.309803922f, 0.768627451f, 1.0f}};
static tfx_uniform main_darkUniform;
static nlfloat32_arr4 main_dark = {.v = {0.0862745098f, 0.0862745098f, 0.105882353f, 1.0f}};
static tfx_uniform main_intensityUniform;
static float main_intensity = 1.0f;
static tfx_uniform main_amountUniform;
static float main_amount = 1.0f;
static main_entity_arr101 main_entitylist;
static uint64_t main_now;
static uint64_t main_last = 0U;
static double main_delta = 0.0;
static bool main_running = true;
static int nelua_main(int nelua_argc, char** nelua_argv);
/* ------------------------------ DEFINITIONS ------------------------------- */
uint64_t nelua_shl_nluint64(uint64_t a, int64_t b) {
  if(NELUA_LIKELY(b >= 0 && b < 64)) {
    return ((uint64_t)a) << b;
  } else if(NELUA_UNLIKELY(b < 0 && b > -64)) {
    return (uint64_t)a >> -b;
  } else {
    return 0;
  }
}
uint64_t nelua_shr_nluint64(uint64_t a, int64_t b) {
  if(NELUA_LIKELY(b >= 0 && b < 64)) {
    return (uint64_t)a >> b;
  } else if(NELUA_UNLIKELY(b < 0 && b > -64)) {
    return (uint64_t)a << -b;
  } else {
    return 0;
  }
}
uint64_t nelua_rotl(uint64_t x, int32_t n) {
  return (nelua_shl_nluint64(x, n) | nelua_shr_nluint64(x, (64 - n)));
}
uint64_t nelua_Xoshiro256_nextrand(nelua_Xoshiro256_ptr self) {
  nluint64_arr4 state = (nluint64_arr4){{(*(nluint64_arr4*)self->state).v[0], (*(nluint64_arr4*)self->state).v[1], ((*(nluint64_arr4*)self->state).v[2] ^ (*(nluint64_arr4*)self->state).v[0]), ((*(nluint64_arr4*)self->state).v[3] ^ (*(nluint64_arr4*)self->state).v[1])}};
  uint64_t res = (nelua_rotl((state.v[1] * 5), 7) * 9);
  (*(nluint64_arr4*)self->state).v[0] = (state.v[0] ^ state.v[3]);
  (*(nluint64_arr4*)self->state).v[1] = (state.v[1] ^ state.v[2]);
  (*(nluint64_arr4*)self->state).v[2] = (state.v[2] ^ (state.v[1] << 17));
  (*(nluint64_arr4*)self->state).v[3] = nelua_rotl(state.v[3], 45);
  return res;
}
double nelua_Xoshiro256_random(nelua_Xoshiro256_ptr self) {
  return ((nelua_Xoshiro256_nextrand(self) >> 11) * 1.1102230246251565e-16);
}
void nelua_Xoshiro256_seed(nelua_Xoshiro256_ptr self, uint64_t a, uint64_t b) {
  (*(nluint64_arr4*)self->state).v[0] = a;
  (*(nluint64_arr4*)self->state).v[1] = 0xffU;
  (*(nluint64_arr4*)self->state).v[2] = b;
  (*(nluint64_arr4*)self->state).v[3] = 0U;
  for(uintptr_t i = 0U; i < 16U; i = i + 1) {
    nelua_Xoshiro256_nextrand(self);
  }
}
nlmulret_nlint64_nlint64 nelua_math_randomseed_1(int64_t x, nlniltype y) {
  uint64_t y_1 = 0U;
  int64_t ix = x;
  int64_t iy = (int64_t)y_1;
  nelua_Xoshiro256_seed((&nelua_default_random), (uint64_t)ix, (uint64_t)iy);
  return (nlmulret_nlint64_nlint64){ix, iy};
}
int64_t nelua_math_random_1(int64_t m, int n) {
  double r = nelua_Xoshiro256_random((&nelua_default_random));
  int64_t low = m;
  int64_t up = (int64_t)n;
  r = (r * ((double)(up - low) + 1.0));
  return ((int64_t)r + low);
}
int64_t nelua_math_random_2(int64_t m, int64_t n) {
  double r = nelua_Xoshiro256_random((&nelua_default_random));
  int64_t low = m;
  int64_t up = n;
  r = (r * ((double)(up - low) + 1.0));
  return ((int64_t)r + low);
}
nlmulret_nlboolean_nlint64_main_entity_ptr nelua_mipairs_next(main_entity_arr101_ptr a_1, int64_t k) {
  k = (k + 1);
  if((k >= 101)) {
    return (nlmulret_nlboolean_nlint64_main_entity_ptr){false, 0, ((main_entity_ptr)NULL)};
  }
  return (nlmulret_nlboolean_nlint64_main_entity_ptr){true, k, (&a_1->v[k])};
}
nlmulret_function_3KD4K8avoExANbbuQ_main_entity_arr101_ptr_nlint64 nelua_mipairs_1(main_entity_arr101_ptr a) {
  return (nlmulret_function_3KD4K8avoExANbbuQ_main_entity_arr101_ptr_nlint64){nelua_mipairs_next, a, -1};
}
nlmulret_function_2aArm761WFweS6BxH_nelua_hashmap_iteratorT_nlpointer nelua_mpairs_1(nelua_hashmap_pointer__GCItem__ptr a) {
  nlmulret_function_2aArm761WFweS6BxH_nelua_hashmap_iteratorT_nlpointer _ret_1 = nelua_hashmap_pointer__GCItem____mpairs(a);
  return (nlmulret_function_2aArm761WFweS6BxH_nelua_hashmap_iteratorT_nlpointer){_ret_1.r1, _ret_1.r2, _ret_1.r3};
}
mat4 libs_math_extra_mat4_new(void) {
  return (mat4){.data = {1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f}};
}
void libs_math_extra_mat4_identity(mat4_ptr a) {
  float _asgntmp_1 = 1.0f;
  float _asgntmp_2 = 0.0f;
  float _asgntmp_3 = 0.0f;
  float _asgntmp_4 = 0.0f;
  (*(nlfloat32_arr16*)a->data).v[0] = _asgntmp_1;
  (*(nlfloat32_arr16*)a->data).v[1] = _asgntmp_2;
  (*(nlfloat32_arr16*)a->data).v[2] = _asgntmp_3;
  (*(nlfloat32_arr16*)a->data).v[3] = _asgntmp_4;
  float _asgntmp_5 = 0.0f;
  float _asgntmp_6 = 1.0f;
  float _asgntmp_7 = 0.0f;
  float _asgntmp_8 = 0.0f;
  (*(nlfloat32_arr16*)a->data).v[4] = _asgntmp_5;
  (*(nlfloat32_arr16*)a->data).v[5] = _asgntmp_6;
  (*(nlfloat32_arr16*)a->data).v[6] = _asgntmp_7;
  (*(nlfloat32_arr16*)a->data).v[7] = _asgntmp_8;
  float _asgntmp_9 = 0.0f;
  float _asgntmp_10 = 0.0f;
  float _asgntmp_11 = 1.0f;
  float _asgntmp_12 = 0.0f;
  (*(nlfloat32_arr16*)a->data).v[8] = _asgntmp_9;
  (*(nlfloat32_arr16*)a->data).v[9] = _asgntmp_10;
  (*(nlfloat32_arr16*)a->data).v[10] = _asgntmp_11;
  (*(nlfloat32_arr16*)a->data).v[11] = _asgntmp_12;
  float _asgntmp_13 = 0.0f;
  float _asgntmp_14 = 0.0f;
  float _asgntmp_15 = 0.0f;
  float _asgntmp_16 = 1.0f;
  (*(nlfloat32_arr16*)a->data).v[12] = _asgntmp_13;
  (*(nlfloat32_arr16*)a->data).v[13] = _asgntmp_14;
  (*(nlfloat32_arr16*)a->data).v[14] = _asgntmp_15;
  (*(nlfloat32_arr16*)a->data).v[15] = _asgntmp_16;
}
mat4 libs_math_extra_mat4_from_ortho(double left, double right, double top, double bottom, double near, double far) {
  mat4 out = libs_math_extra_mat4_new();
  out.data[0] = (float)(2 / (right - left));
  out.data[5] = (float)(2 / (top - bottom));
  out.data[10] = (float)(-2 / (far - near));
  out.data[12] = (float)(-((right + left) / (right - left)));
  out.data[13] = (float)(-((top + bottom) / (top - bottom)));
  out.data[14] = (float)(-((far + near) / (far - near)));
  out.data[15] = 1.0f;
  return out;
}
mat4 libs_math_extra_mat4___mul(mat4 a, mat4 b) {
  mat4 out = libs_math_extra_mat4_new();
  out.data[0] = ((((a.data[0] * b.data[0]) + (a.data[1] * b.data[4])) + (a.data[2] * b.data[8])) + (a.data[3] * b.data[12]));
  out.data[1] = ((((a.data[0] * b.data[1]) + (a.data[1] * b.data[5])) + (a.data[2] * b.data[9])) + (a.data[3] * b.data[13]));
  out.data[2] = ((((a.data[0] * b.data[2]) + (a.data[1] * b.data[6])) + (a.data[2] * b.data[10])) + (a.data[3] * b.data[14]));
  out.data[3] = ((((a.data[0] * b.data[3]) + (a.data[1] * b.data[7])) + (a.data[2] * b.data[11])) + (a.data[3] * b.data[15]));
  out.data[4] = ((((a.data[4] * b.data[0]) + (a.data[5] * b.data[4])) + (a.data[6] * b.data[8])) + (a.data[7] * b.data[12]));
  out.data[5] = ((((a.data[4] * b.data[1]) + (a.data[5] * b.data[5])) + (a.data[6] * b.data[9])) + (a.data[7] * b.data[13]));
  out.data[6] = ((((a.data[4] * b.data[2]) + (a.data[5] * b.data[6])) + (a.data[6] * b.data[10])) + (a.data[7] * b.data[14]));
  out.data[7] = ((((a.data[4] * b.data[3]) + (a.data[5] * b.data[7])) + (a.data[6] * b.data[11])) + (a.data[7] * b.data[15]));
  out.data[8] = ((((a.data[8] * b.data[0]) + (a.data[9] * b.data[4])) + (a.data[10] * b.data[8])) + (a.data[11] * b.data[12]));
  out.data[9] = ((((a.data[8] * b.data[1]) + (a.data[9] * b.data[5])) + (a.data[10] * b.data[9])) + (a.data[11] * b.data[13]));
  out.data[10] = ((((a.data[8] * b.data[2]) + (a.data[9] * b.data[6])) + (a.data[10] * b.data[10])) + (a.data[11] * b.data[14]));
  out.data[11] = ((((a.data[8] * b.data[3]) + (a.data[9] * b.data[7])) + (a.data[10] * b.data[11])) + (a.data[11] * b.data[15]));
  out.data[12] = ((((a.data[12] * b.data[0]) + (a.data[13] * b.data[4])) + (a.data[14] * b.data[8])) + (a.data[15] * b.data[12]));
  out.data[13] = ((((a.data[12] * b.data[1]) + (a.data[13] * b.data[5])) + (a.data[14] * b.data[9])) + (a.data[15] * b.data[13]));
  out.data[14] = ((((a.data[12] * b.data[2]) + (a.data[13] * b.data[6])) + (a.data[14] * b.data[10])) + (a.data[15] * b.data[14]));
  out.data[15] = ((((a.data[12] * b.data[3]) + (a.data[13] * b.data[7])) + (a.data[14] * b.data[11])) + (a.data[15] * b.data[15]));
  return out;
}
mat4 libs_math_extra_mat4_translate(mat4 a, libs_math_extra_vec3 b) {
  libs_math_extra_mat4_identity((&libs_math_extra_tmp));
  libs_math_extra_tmp.data[12] = (float)b.x;
  libs_math_extra_tmp.data[13] = (float)b.y;
  libs_math_extra_tmp.data[14] = (float)b.z;
  return libs_math_extra_mat4___mul(a, libs_math_extra_tmp);
}
mat4 libs_math_extra_mat4_scale(mat4 a, libs_math_extra_vec3 b) {
  libs_math_extra_mat4_identity((&libs_math_extra_tmp));
  libs_math_extra_tmp.data[0] = (float)b.x;
  libs_math_extra_tmp.data[5] = (float)b.y;
  libs_math_extra_tmp.data[10] = (float)b.z;
  return libs_math_extra_mat4___mul(a, libs_math_extra_tmp);
}
void nelua_memory_zero(void* dest, uintptr_t n) {
  if(NELUA_UNLIKELY((n == 0))) {
    return;
  }
  memset(dest, 0, (size_t)n);
}
nlpointer_ptr nelua_span_pointer____atindex(nelua_span_pointer__ptr self, uintptr_t i) {
  return (&self->data[i]);
}
nlusize_ptr nelua_span_usize____atindex(nelua_span_usize__ptr self, uintptr_t i) {
  return (&self->data[i]);
}
nelua_hashmapnode_pointer__GCItem__ptr nelua_span_hashmapnode_pointer__GCItem_____atindex(nelua_span_hashmapnode_pointer__GCItem___ptr self, uintptr_t i) {
  return (&self->data[i]);
}
void nelua_memory_spanset_1(nelua_span_usize_ dest, uintptr_t x) {
  for(uintptr_t i = 0U, _end = dest.size; i < _end; i = i + 1) {
    memcpy((void*)(&(*nelua_span_usize____atindex((&dest), i))), (void*)(&x), 8U);
  }
}
void* nelua_GeneralAllocator_alloc(nelua_GeneralAllocator_ptr self, uintptr_t size) {
  if(NELUA_UNLIKELY((size == 0))) {
    return (void*)NULL;
  }
  return malloc((size_t)size);
}
void* nelua_GeneralAllocator_alloc0(nelua_GeneralAllocator_ptr self, uintptr_t size) {
  if(NELUA_UNLIKELY((size == 0))) {
    return (void*)NULL;
  }
  return calloc((size_t)size, 1U);
}
void nelua_GeneralAllocator_dealloc(nelua_GeneralAllocator_ptr self, void* p) {
  if(NELUA_UNLIKELY((p == (void*)NULL))) {
    return;
  }
  free(p);
}
void* nelua_GeneralAllocator_realloc(nelua_GeneralAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize) {
  if(NELUA_UNLIKELY((newsize == 0))) {
    if(NELUA_LIKELY((p != (void*)NULL))) {
      free(p);
    }
    return (void*)NULL;
  } else if(NELUA_UNLIKELY((newsize == oldsize))) {
    return p;
  }
  return realloc(p, (size_t)newsize);
}
void* nelua_GeneralAllocator_realloc0(nelua_GeneralAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize) {
  p = nelua_GeneralAllocator_realloc(self, p, newsize, oldsize);
  if(NELUA_LIKELY(((newsize > oldsize) && (p != (void*)NULL)))) {
    nelua_memory_zero((void*)(&((nluint8_arr0_ptr)p)[oldsize]), (newsize - oldsize));
  }
  return p;
}
nelua_span_pointer_ nelua_GeneralAllocator_spanalloc_1(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size) {
  if(NELUA_LIKELY((size > 0))) {
    nlpointer_arr0_ptr data = ((nlpointer_arr0_ptr)nelua_GeneralAllocator_alloc(self, (size * 8)));
    if(NELUA_LIKELY((data != ((nlpointer_arr0_ptr)NULL)))) {
      return (nelua_span_pointer_){data, size};
    }
  }
  return (nelua_span_pointer_){0};
}
nelua_span_usize_ nelua_GeneralAllocator_spanalloc_2(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size) {
  if(NELUA_LIKELY((size > 0))) {
    nlusize_arr0_ptr data = ((nlusize_arr0_ptr)nelua_GeneralAllocator_alloc(self, (size * 8)));
    if(NELUA_LIKELY((data != ((nlusize_arr0_ptr)NULL)))) {
      return (nelua_span_usize_){data, size};
    }
  }
  return (nelua_span_usize_){0};
}
nelua_span_hashmapnode_pointer__GCItem__ nelua_GeneralAllocator_spanalloc0_1(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size) {
  if(NELUA_LIKELY((size > 0))) {
    nelua_hashmapnode_pointer__GCItem__arr0_ptr data = ((nelua_hashmapnode_pointer__GCItem__arr0_ptr)nelua_GeneralAllocator_alloc0(self, (size * 64)));
    if(NELUA_LIKELY((data != ((nelua_hashmapnode_pointer__GCItem__arr0_ptr)NULL)))) {
      return (nelua_span_hashmapnode_pointer__GCItem__){data, size};
    }
  }
  return (nelua_span_hashmapnode_pointer__GCItem__){0};
}
void nelua_GeneralAllocator_spandealloc_1(nelua_GeneralAllocator_ptr self, nelua_span_pointer_ s) {
  if(NELUA_UNLIKELY((s.size == 0))) {
    return;
  }
  nelua_GeneralAllocator_dealloc(self, (void*)s.data);
}
void nelua_GeneralAllocator_spandealloc_2(nelua_GeneralAllocator_ptr self, nelua_span_usize_ s) {
  if(NELUA_UNLIKELY((s.size == 0))) {
    return;
  }
  nelua_GeneralAllocator_dealloc(self, (void*)s.data);
}
void nelua_GeneralAllocator_spandealloc_3(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_pointer__GCItem__ s) {
  if(NELUA_UNLIKELY((s.size == 0))) {
    return;
  }
  nelua_GeneralAllocator_dealloc(self, (void*)s.data);
}
nelua_span_pointer_ nelua_GeneralAllocator_spanrealloc_1(nelua_GeneralAllocator_ptr self, nelua_span_pointer_ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GeneralAllocator_spanalloc_1(self, NELUA_NIL, size);
    return s;
  }
  nlpointer_arr0_ptr p = ((nlpointer_arr0_ptr)nelua_GeneralAllocator_realloc(self, (void*)s.data, (size * 8), s.size));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((nlpointer_arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_usize_ nelua_GeneralAllocator_spanrealloc_2(nelua_GeneralAllocator_ptr self, nelua_span_usize_ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GeneralAllocator_spanalloc_2(self, NELUA_NIL, size);
    return s;
  }
  nlusize_arr0_ptr p = ((nlusize_arr0_ptr)nelua_GeneralAllocator_realloc(self, (void*)s.data, (size * 8), s.size));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((nlusize_arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
void nelua_abort(void) {
  fflush(stderr);
  NELUA_UBSAN_UNREACHABLE();
  abort();
}
void nelua_panic_string(nlstring s) {
  if(s.size > 0) {
    fwrite(s.data, 1, s.size, stderr);
    fputc('\n', stderr);
  }
  nelua_abort();
}
nelua_span_pointer_ nelua_GeneralAllocator_xspanrealloc_1(nelua_GeneralAllocator_ptr self, nelua_span_pointer_ s, uintptr_t size) {
  s = nelua_GeneralAllocator_spanrealloc_1(self, s, size);
  if(NELUA_UNLIKELY((s.size != size))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return s;
}
nelua_span_usize_ nelua_GeneralAllocator_xspanrealloc_2(nelua_GeneralAllocator_ptr self, nelua_span_usize_ s, uintptr_t size) {
  s = nelua_GeneralAllocator_spanrealloc_2(self, s, size);
  if(NELUA_UNLIKELY((s.size != size))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return s;
}
nelua_span_hashmapnode_pointer__GCItem__ nelua_GeneralAllocator_spanrealloc0_1(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_pointer__GCItem__ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GeneralAllocator_spanalloc0_1(self, NELUA_NIL, size);
    return s;
  }
  nelua_hashmapnode_pointer__GCItem__arr0_ptr p = ((nelua_hashmapnode_pointer__GCItem__arr0_ptr)nelua_GeneralAllocator_realloc0(self, (void*)s.data, (size * 64), (s.size * 64)));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((nelua_hashmapnode_pointer__GCItem__arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_hashmapnode_pointer__GCItem__ nelua_GeneralAllocator_xspanrealloc0_1(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_pointer__GCItem__ s, uintptr_t size) {
  s = nelua_GeneralAllocator_spanrealloc0_1(self, s, size);
  if(NELUA_UNLIKELY((s.size != size))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return s;
}
uintptr_t nelua_hash_hash_1(void* v) {
  return ((uintptr_t)v >> 3);
}
uintptr_t nelua_ceilidiv(uintptr_t x, uintptr_t y) {
  return (((x + y) - 1) / y);
}
uintptr_t nelua_hashmod(uintptr_t h, uintptr_t n) {
  return (h % ((n - 1) | 1));
}
uintptr_t nelua_roundpow2(uintptr_t n) {
  if(((n & (n - 1)) == 0)) {
    return n;
  }
  n = (n | (n >> 1));
  n = (n | (n >> 2));
  n = (n | (n >> 4));
  n = (n | (n >> 8));
  n = (n | (n >> 16));
  if(true) {
    n = (n | (n >> 32));
  }
  n = (n + 1);
  return n;
}
void nelua_hashmap_pointer__GCItem__destroy(nelua_hashmap_pointer__GCItem__ptr self) {
  nelua_GeneralAllocator_spandealloc_2((&self->allocator), self->buckets);
  nelua_GeneralAllocator_spandealloc_3((&self->allocator), self->nodes);
  self->buckets = (nelua_span_usize_){0};
  self->nodes = (nelua_span_hashmapnode_pointer__GCItem__){0};
  self->size = 0U;
  self->free_index = 0U;
}
nlmulret_nlusize_nlusize_nlusize nelua_hashmap_pointer__GCItem___find(nelua_hashmap_pointer__GCItem__ptr self, void* key) {
  uintptr_t hash_index = nelua_hashmod(nelua_hash_hash_1(key), self->buckets.size);
  uintptr_t prev_node_index = 0xffffffffffffffffULL;
  if(NELUA_UNLIKELY((self->buckets.size == 0))) {
    return (nlmulret_nlusize_nlusize_nlusize){0xffffffffffffffffULL, prev_node_index, hash_index};
  }
  uintptr_t node_index = (*nelua_span_usize____atindex((&self->buckets), hash_index));
  while((node_index != 0xffffffffffffffffULL)) {
    nelua_hashmapnode_pointer__GCItem__ptr node = (&(*nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->nodes), node_index)));
    if((node->key == key)) {
      return (nlmulret_nlusize_nlusize_nlusize){node_index, prev_node_index, hash_index};
    }
    prev_node_index = node_index;
    node_index = node->next;
  }
  return (nlmulret_nlusize_nlusize_nlusize){node_index, prev_node_index, hash_index};
}
void nelua_hashmap_pointer__GCItem__rehash(nelua_hashmap_pointer__GCItem__ptr self, uintptr_t bucket_count) {
  uintptr_t min_buckets_count = nelua_ceilidiv((self->size * 100), 75U);
  if((bucket_count < min_buckets_count)) {
    bucket_count = min_buckets_count;
  }
  bucket_count = nelua_roundpow2(bucket_count);
  uintptr_t node_count = nelua_ceilidiv((bucket_count * 75U), 100U);
  if(((bucket_count > 0) && (node_count <= self->size))) {
    node_count = (self->size + 1);
  }
  if((((node_count < self->nodes.size) && (self->nodes.size > 0)) && (node_count > 0))) {
    uintptr_t j = 0U;
    while(((j < self->nodes.size) && (*nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->nodes), j)).filled)) {
      j = (j + 1);
    }
    for(uintptr_t i = j, _end = self->nodes.size; i < _end; i = i + 1) {
      if((*nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->nodes), i)).filled) {
        (*nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->nodes), j)) = (*nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->nodes), i));
        j = (j + 1);
      }
    }
    for(uintptr_t i = j, _end = self->nodes.size; i < _end; i = i + 1) {
      (*nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->nodes), i)) = (nelua_hashmapnode_pointer__GCItem_){0};
    }
  }
  self->nodes = nelua_GeneralAllocator_xspanrealloc0_1((&self->allocator), self->nodes, node_count);
  self->buckets = nelua_GeneralAllocator_xspanrealloc_2((&self->allocator), self->buckets, bucket_count);
  nelua_memory_spanset_1(self->buckets, 0xffffffffffffffffULL);
  uintptr_t free_index = 0xffffffffffffffffULL;
  for(intptr_t i = (intptr_t)(self->nodes.size - 1); i >= 0; i = i + -1) {
    nelua_hashmapnode_pointer__GCItem__ptr node = (&(*nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->nodes), (uintptr_t)i)));
    if(node->filled) {
      node->next = 0xffffffffffffffffULL;
    } else {
      node->next = free_index;
      free_index = (uintptr_t)i;
    }
  }
  self->free_index = free_index;
  for(uintptr_t i = 0U, _end = self->nodes.size; i < _end; i = i + 1) {
    if((*nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->nodes), i)).filled) {
      nlmulret_nlusize_nlusize_nlusize _asgnret_1 = nelua_hashmap_pointer__GCItem___find(self, (*nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->nodes), i)).key);
      uintptr_t node_index = _asgnret_1.r1;
      uintptr_t prev_node_index = _asgnret_1.r2;
      uintptr_t hash_index = _asgnret_1.r3;
      if((prev_node_index == 0xffffffffffffffffULL)) {
        (*nelua_span_usize____atindex((&self->buckets), hash_index)) = i;
      } else {
        (*nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->nodes), prev_node_index)).next = i;
      }
      (*nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->nodes), i)).next = node_index;
    }
  }
}
uintptr_t nelua_hashmap_pointer__GCItem___at(nelua_hashmap_pointer__GCItem__ptr self, void* key) {
  if(NELUA_UNLIKELY((self->buckets.size == 0))) {
    nelua_hashmap_pointer__GCItem__rehash(self, 16U);
  }
  nlmulret_nlusize_nlusize_nlusize _asgnret_1 = nelua_hashmap_pointer__GCItem___find(self, key);
  uintptr_t node_index = _asgnret_1.r1;
  uintptr_t prev_node_index = _asgnret_1.r2;
  uintptr_t hash_index = _asgnret_1.r3;
  if((node_index != 0xffffffffffffffffULL)) {
    return node_index;
  } else {
    uintptr_t node_index_1 = self->free_index;
    nelua_hashmapnode_pointer__GCItem__ptr node = (&(*nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->nodes), node_index_1)));
    self->free_index = node->next;
    (*node) = (nelua_hashmapnode_pointer__GCItem_){.key = key, .filled = true, .next = 0xffffffffffffffffULL};
    if((prev_node_index == 0xffffffffffffffffULL)) {
      (*nelua_span_usize____atindex((&self->buckets), hash_index)) = node_index_1;
    } else {
      (*nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->nodes), prev_node_index)).next = node_index_1;
    }
    self->size = (self->size + 1);
    if(NELUA_UNLIKELY(((self->size * 100) >= (self->buckets.size * 75U)))) {
      nelua_hashmap_pointer__GCItem__rehash(self, nelua_ceilidiv((self->size * 200U), 75U));
    }
    return node_index_1;
  }
}
nelua_GCItem_ptr nelua_hashmap_pointer__GCItem____atindex(nelua_hashmap_pointer__GCItem__ptr self, void* key) {
  return (&(*nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->nodes), nelua_hashmap_pointer__GCItem___at(self, key))).value);
}
nelua_GCItem_ptr nelua_hashmap_pointer__GCItem__peek(nelua_hashmap_pointer__GCItem__ptr self, void* key) {
  uintptr_t node_index = nelua_hashmap_pointer__GCItem___find(self, key).r1;
  if((node_index != 0xffffffffffffffffULL)) {
    return (&(*nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->nodes), node_index)).value);
  }
  return ((nelua_GCItem_ptr)NULL);
}
nelua_GCItem nelua_hashmap_pointer__GCItem__remove(nelua_hashmap_pointer__GCItem__ptr self, void* key) {
  nlmulret_nlusize_nlusize_nlusize _asgnret_1 = nelua_hashmap_pointer__GCItem___find(self, key);
  uintptr_t node_index = _asgnret_1.r1;
  uintptr_t prev_node_index = _asgnret_1.r2;
  uintptr_t hash_index = _asgnret_1.r3;
  if((node_index == 0xffffffffffffffffULL)) {
    return (nelua_GCItem){0};
  }
  nelua_hashmapnode_pointer__GCItem__ptr node = (&(*nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->nodes), node_index)));
  nelua_GCItem value = node->value;
  if((prev_node_index == 0xffffffffffffffffULL)) {
    (*nelua_span_usize____atindex((&self->buckets), hash_index)) = node->next;
  } else {
    (*nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->nodes), prev_node_index)).next = node->next;
  }
  self->size = (self->size - 1);
  (*node) = (nelua_hashmapnode_pointer__GCItem_){.next = self->free_index};
  self->free_index = node_index;
  return value;
}
uintptr_t nelua_hashmap_pointer__GCItem__bucketcount(nelua_hashmap_pointer__GCItem__ptr self) {
  return self->buckets.size;
}
nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr nelua_hashmap_iteratorT_mnext(nelua_hashmap_iteratorT_ptr self, void* key) {
  if(NELUA_UNLIKELY((self->index == 0xffffffffffffffffULL))) {
    self->index = 0U;
  } else {
    self->index = (self->index + 1);
  }
  while((self->index < self->container->nodes.size)) {
    nelua_hashmapnode_pointer__GCItem__ptr node = (&(*nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->container->nodes), self->index)));
    if(node->filled) {
      return (nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr){true, node->key, (&node->value)};
    }
    self->index = (self->index + 1);
  }
  return (nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr){false, NULL, ((nelua_GCItem_ptr)NULL)};
}
nlmulret_function_2aArm761WFweS6BxH_nelua_hashmap_iteratorT_nlpointer nelua_hashmap_pointer__GCItem____mpairs(nelua_hashmap_pointer__GCItem__ptr self) {
  return (nlmulret_function_2aArm761WFweS6BxH_nelua_hashmap_iteratorT_nlpointer){nelua_hashmap_iteratorT_mnext, (nelua_hashmap_iteratorT){.container = self, .index = 0xffffffffffffffffULL}, NULL};
}
void nelua_vector_pointer__clear(nelua_vector_pointer__ptr self) {
  self->size = 0U;
}
void nelua_vector_pointer__destroy(nelua_vector_pointer__ptr self) {
  nelua_GeneralAllocator_spandealloc_1((&self->allocator), self->data);
  self->data = (nelua_span_pointer_){0};
  self->size = 0U;
}
void nelua_vectorT_grow(nelua_vector_pointer__ptr self) {
  uintptr_t cap = 1U;
  if(NELUA_LIKELY((self->data.size != 0))) {
    cap = (self->data.size * 2);
  }
  self->data = nelua_GeneralAllocator_xspanrealloc_1((&self->allocator), self->data, cap);
}
void nelua_vector_pointer__push(nelua_vector_pointer__ptr self, void* v) {
  uintptr_t newsize = (self->size + 1);
  if(NELUA_UNLIKELY((newsize > self->data.size))) {
    nelua_vectorT_grow(self);
  }
  (*nelua_span_pointer____atindex((&self->data), self->size)) = v;
  self->size = newsize;
}
nlpointer_ptr nelua_vector_pointer____atindex(nelua_vector_pointer__ptr self, uintptr_t pos) {
  return (&(*nelua_span_pointer____atindex((&self->data), pos)));
}
bool nelua_hasflag(uintptr_t flags, uintptr_t flag) {
  return ((flags & flag) != 0);
}
bool nelua_GCItem_ismarked(nelua_GCItem_ptr self) {
  return nelua_hasflag(self->flags, 3U);
}
void nelua_GC_markptrs(nelua_GC_ptr self, uintptr_t low, uintptr_t high) {
  uintptr_t minaddr = self->minaddr;
  uintptr_t maxaddr = self->maxaddr;
  nelua_hashmap_pointer__GCItem__ptr items = (&self->items);
  for(uintptr_t memaddr = low, _end = high; memaddr < _end; memaddr = memaddr + 8) {
    uintptr_t addr = (*(nlusize_ptr)memaddr);
    if(((addr >= minaddr) && (addr <= maxaddr))) {
      nelua_GCItem_ptr item = nelua_hashmap_pointer__GCItem__peek(items, (void*)addr);
      if(((item != NULL) && (!nelua_GCItem_ismarked(item)))) {
        item->flags = (item->flags | 1U);
        if((!nelua_hasflag(item->flags, 4U))) {
          nelua_GC_markptrs(self, addr, (addr + item->size));
        }
      }
    }
  }
}
void nelua_GC_unmarkall(nelua_GC_ptr self) {
  {
    nlmulret_function_2aArm761WFweS6BxH_nelua_hashmap_iteratorT_nlpointer _asgnret_1 = nelua_mpairs_1((&self->items));
    function_2aArm761WFweS6BxH __fornext = _asgnret_1.r1;
    nelua_hashmap_iteratorT __forstate = _asgnret_1.r2;
    void* __forit = _asgnret_1.r3;
    while(true) {
      bool __forcont;
      nelua_GCItem_ptr item;
      nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr _asgnret_2 = __fornext((&__forstate), __forit);
      __forcont = _asgnret_2.r1;
      __forit = _asgnret_2.r2;
      item = _asgnret_2.r3;
      if((!__forcont)) {
        break;
      }
      __forit;
      {
        item->flags = (item->flags & 18446744073709551614ULL);
      }
    }
  }
}
void nelua_GC_markroot(nelua_GC_ptr self) {
  {
    nlmulret_function_2aArm761WFweS6BxH_nelua_hashmap_iteratorT_nlpointer _asgnret_1 = nelua_mpairs_1((&self->items));
    function_2aArm761WFweS6BxH __fornext = _asgnret_1.r1;
    nelua_hashmap_iteratorT __forstate = _asgnret_1.r2;
    void* __forit = _asgnret_1.r3;
    while(true) {
      bool __forcont;
      nelua_GCItem_ptr item;
      nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr _asgnret_2 = __fornext((&__forstate), __forit);
      __forcont = _asgnret_2.r1;
      __forit = _asgnret_2.r2;
      item = _asgnret_2.r3;
      if((!__forcont)) {
        break;
      }
      void* ptr = __forit;
      {
        if(nelua_hasflag(item->flags, 2U)) {
          uintptr_t addr = (uintptr_t)ptr;
          nelua_GC_markptrs(self, addr, (addr + item->size));
        }
      }
    }
  }
}
void nelua_GC_markstackinner(nelua_GC_ptr self) {
  volatile void* stacktop = NULL;
  uintptr_t low = (uintptr_t)self->stackbottom;
  uintptr_t high = (uintptr_t)(&stacktop);
  if((high < low)) {
    uintptr_t _asgntmp_1 = high;
    uintptr_t _asgntmp_2 = low;
    low = _asgntmp_1;
    high = _asgntmp_2;
  }
  nelua_GC_markptrs(self, low, high);
}
void nelua_GC_markstack(nelua_GC_ptr self) {
  jmp_buf regs = {0};
  setjmp(regs);
  volatile function_42YwF3raoDCqXkrMb markstackinner = nelua_GC_markstackinner;
  markstackinner(self);
}
void nelua_GC_mark(nelua_GC_ptr self) {
  nelua_GC_unmarkall(self);
  nelua_GC_markroot(self);
  nelua_GC_markstack(self);
}
void nelua_GC_sweep(nelua_GC_ptr self) {
  bool finalize = false;
  {
    nlmulret_function_2aArm761WFweS6BxH_nelua_hashmap_iteratorT_nlpointer _asgnret_1 = nelua_mpairs_1((&self->items));
    function_2aArm761WFweS6BxH __fornext = _asgnret_1.r1;
    nelua_hashmap_iteratorT __forstate = _asgnret_1.r2;
    void* __forit = _asgnret_1.r3;
    while(true) {
      bool __forcont;
      nelua_GCItem_ptr item;
      nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr _asgnret_2 = __fornext((&__forstate), __forit);
      __forcont = _asgnret_2.r1;
      __forit = _asgnret_2.r2;
      item = _asgnret_2.r3;
      if((!__forcont)) {
        break;
      }
      void* ptr = __forit;
      {
        if((!nelua_GCItem_ismarked(item))) {
          nelua_vector_pointer__push((&self->frees), ptr);
          if(((!finalize) && (item->finalizer != NULL))) {
            finalize = true;
          }
        }
      }
    }
  }
  if(finalize) {
    uintptr_t i = 0U;
    while((i < self->frees.size)) {
      void* ptr = (*nelua_vector_pointer____atindex((&self->frees), i));
      if((ptr != NULL)) {
        nelua_GCItem_ptr item = nelua_hashmap_pointer__GCItem__peek((&self->items), ptr);
        if(((item != NULL) && (item->finalizer != NULL))) {
          nelua_GCFinalizerCallback finalizer = item->finalizer;
          item->finalizer = (nelua_GCFinalizerCallback)NULL;
          finalizer(ptr, item->userdata);
        }
      }
      i = (i + 1);
    }
  }
  uintptr_t i = 0U;
  while((i < self->frees.size)) {
    void* ptr = (*nelua_vector_pointer____atindex((&self->frees), i));
    if((ptr != NULL)) {
      nelua_GCItem item = nelua_hashmap_pointer__GCItem__remove((&self->items), ptr);
      if((item.ptr != NULL)) {
        self->membytes = (self->membytes - item.size);
        if((!nelua_hasflag(item.flags, 8U))) {
          nelua_GeneralAllocator_dealloc((&nelua_general_allocator), ptr);
        }
      }
    }
    i = (i + 1);
  }
  nelua_vector_pointer__clear((&self->frees));
}
void nelua_GC_collect(nelua_GC_ptr self) {
  if((self->collecting || (self->membytes == 0))) {
    return;
  }
  self->collecting = true;
  nelua_GC_mark(self);
  nelua_GC_sweep(self);
  self->lastmembytes = self->membytes;
  if(((self->items.size * 4) < nelua_hashmap_pointer__GCItem__bucketcount((&self->items)))) {
    nelua_hashmap_pointer__GCItem__rehash((&self->items), 0U);
  }
  self->collecting = false;
}
void nelua_GC_registerroots(nelua_GC_ptr self) {
  nelua_GC_register((&nelua_gc), (void*)(&main_window), 8U, 2U, (function_3SCL8hZZUmGrg3Fpt)NULL, (void*)NULL);
  nelua_GC_register((&nelua_gc), (void*)(&main_context), 8U, 2U, (function_3SCL8hZZUmGrg3Fpt)NULL, (void*)NULL);
  nelua_GC_register((&nelua_gc), (void*)(&main_attribs), 16U, 2U, (function_3SCL8hZZUmGrg3Fpt)NULL, (void*)NULL);
  nelua_GC_register((&nelua_gc), (void*)(&main_vbo), 232U, 2U, (function_3SCL8hZZUmGrg3Fpt)NULL, (void*)NULL);
  nelua_GC_register((&nelua_gc), (void*)(&main_projectionUniform), 48U, 2U, (function_3SCL8hZZUmGrg3Fpt)NULL, (void*)NULL);
  nelua_GC_register((&nelua_gc), (void*)(&main_modelUniform), 48U, 2U, (function_3SCL8hZZUmGrg3Fpt)NULL, (void*)NULL);
  nelua_GC_register((&nelua_gc), (void*)(&main_colorUniform), 48U, 2U, (function_3SCL8hZZUmGrg3Fpt)NULL, (void*)NULL);
  nelua_GC_register((&nelua_gc), (void*)(&main_lightUniform), 48U, 2U, (function_3SCL8hZZUmGrg3Fpt)NULL, (void*)NULL);
  nelua_GC_register((&nelua_gc), (void*)(&main_darkUniform), 48U, 2U, (function_3SCL8hZZUmGrg3Fpt)NULL, (void*)NULL);
  nelua_GC_register((&nelua_gc), (void*)(&main_intensityUniform), 48U, 2U, (function_3SCL8hZZUmGrg3Fpt)NULL, (void*)NULL);
  nelua_GC_register((&nelua_gc), (void*)(&main_amountUniform), 48U, 2U, (function_3SCL8hZZUmGrg3Fpt)NULL, (void*)NULL);
}
void nelua_GC_maybecollect(nelua_GC_ptr self) {
  if(((self->running && (!self->collecting)) && ((self->membytes * 100) >= (self->lastmembytes * self->pause)))) {
    nelua_GC_collect(self);
  }
}
void nelua_GC_register(nelua_GC_ptr self, void* ptr, uintptr_t size, uintptr_t flags, function_3SCL8hZZUmGrg3Fpt finalizer, void* userdata) {
  if(NELUA_UNLIKELY((!(ptr != NULL)))) {
    return;
  }
  if((size < 8)) {
    flags = (flags | 4U);
  }
  nelua_GCItem_ptr item = (&(*nelua_hashmap_pointer__GCItem____atindex((&self->items), ptr)));
  (*item) = (nelua_GCItem){.flags = flags, .size = size, .ptr = ptr, .finalizer = finalizer, .userdata = userdata};
  if((!nelua_hasflag(item->flags, 2U))) {
    uintptr_t addr = (uintptr_t)ptr;
    uintptr_t addrhigh = (addr + size);
    if((addrhigh > self->maxaddr)) {
      self->maxaddr = addrhigh;
    }
    if((addr < self->minaddr)) {
      self->minaddr = addr;
    }
  }
  self->membytes = (self->membytes + size);
  nelua_GC_maybecollect(self);
}
void nelua_GC_restart(nelua_GC_ptr self) {
  self->running = true;
}
void nelua_GC_init(nelua_GC_ptr self, void* stack) {
  self->stackbottom = stack;
  self->minaddr = 0xffffffffffffffffULL;
  self->pause = 200U;
  nelua_GC_registerroots(self);
  nelua_GC_restart(self);
}
void nelua_GC_destroy(nelua_GC_ptr self) {
  nelua_GC_unmarkall(self);
  nelua_GC_sweep(self);
  nelua_hashmap_pointer__GCItem__destroy((&self->items));
  nelua_vector_pointer__destroy((&self->frees));
  (*self) = (nelua_GC){0};
}
int main(int argc, nlcstring_ptr argv) {
  nelua_GC_init((&nelua_gc), (void*)(&argc));
  volatile function_whyVgXTXPjxLVKu7 inner_main = nelua_main;
  int ret = inner_main(argc, argv);
  nelua_GC_destroy((&nelua_gc));
  return ret;
}
void nelua_assert_line_1(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/os.nelua\033[1m:242:14: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 78, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n    assert(t > 0, 'time result cannot be represented in this installation')\n             \033[1m\033[32m^\033[0m\033[35m~~\033[0m\n", 1, 120, stderr);
    nelua_abort();
  }
}
int64_t nelua_os_time_1(nlniltype desc) {
  time_t t = 0;
  t = time((nlctime_t_ptr)NULL);
  nelua_assert_line_1((t > 0), ((nlstring){(uint8_t*)"time result cannot be represented in this installation", 54}));
  return (int64_t)t;
}
char* nelua_string2cstring(nlstring s) {
  return (s.size == 0) ? (char*)"" : (char*)s.data;
}
int nelua_main(int nelua_argc, char** nelua_argv) {
  { /* require 'libs.math_extra' */
    libs_math_extra_tmp = libs_math_extra_mat4_new();
  }
  nelua_math_randomseed_1(nelua_os_time_1(NELUA_NIL), NELUA_NIL);
  main_window = SDL_CreateWindow("sdl2", 0, 0, 640, 420, 34U);
  SDL_GL_SetAttribute(0, 8);
  SDL_GL_SetAttribute(1, 8);
  SDL_GL_SetAttribute(2, 8);
  SDL_GL_SetAttribute(3, 0);
  SDL_GL_SetAttribute(6, 16);
  SDL_GL_SetAttribute(21, 4);
  SDL_GL_SetAttribute(17, 3);
  SDL_GL_SetAttribute(18, 1);
  SDL_GL_SetAttribute(20, 1);
  main_context = SDL_GL_CreateContext(main_window);
  SDL_GL_GetDrawableSize(main_window, (&main_g_width), (&main_g_height));
  SDL_GL_MakeCurrent(main_window, main_context);
  SDL_GL_SetSwapInterval(1);
  tfx_set_platform_data((tfx_platform_data){.use_gles = true, .context_version = 31, .gl_get_proc_address = SDL_GL_GetProcAddress});
  tfx_reset((uint16_t)main_g_width, (uint16_t)main_g_height, 14);
  tfx_view_set_clear_color((uint8_t)main_back, 0x16161bffU);
  tfx_view_set_clear_depth((uint8_t)main_back, 1.0f);
  tfx_view_set_depth_test((uint8_t)main_back, 1);
  tfx_view_set_name((uint8_t)main_back, "Forward Pass");
  main_program = tfx_program_new(nelua_string2cstring(((nlstring){(uint8_t*)nelua_strlit_1, 793})), nelua_string2cstring(((nlstring){(uint8_t*)nelua_strlit_1, 793})), ((nlcstring_arr0_ptr)(&main_attribs)), 2);
  main_fmt = tfx_vertex_format_start();
  tfx_vertex_format_add((&main_fmt), 0U, 3U, false, 0);
  tfx_vertex_format_add((&main_fmt), 1U, 2U, false, 0);
  tfx_vertex_format_end((&main_fmt));
  main_vbo = tfx_buffer_new(((nlfloat32_arr0_ptr)(&main_verts)), 120U, (&main_fmt), 0);
  main_projection = libs_math_extra_mat4_from_ortho(0.0, (double)main_g_width, 0.0, (double)main_g_height, -10.0, 10.0);
  main_projectionUniform = tfx_uniform_new("projection", 7, 1);
  tfx_set_uniform((&main_projectionUniform), ((nlfloat32_arr0_ptr)(&(*(nlfloat32_arr16*)main_projection.data))), 1);
  main_model = libs_math_extra_mat4_translate(libs_math_extra_mat4_scale(libs_math_extra_mat4_new(), (libs_math_extra_vec3){.x = 30.0, .y = 30.0, .z = 1.0}), (libs_math_extra_vec3){.x = 200.0, .y = 0.0, .z = 5.0});
  main_modelUniform = tfx_uniform_new("model", 7, 1);
  tfx_set_uniform((&main_modelUniform), ((nlfloat32_arr0_ptr)(&(*(nlfloat32_arr16*)main_model.data))), 1);
  main_colorUniform = tfx_uniform_new("mainColor", 4, 1);
  tfx_set_uniform((&main_colorUniform), ((nlfloat32_arr0_ptr)(&main_color)), 1);
  main_lightUniform = tfx_uniform_new("light", 4, 1);
  tfx_set_uniform((&main_lightUniform), ((nlfloat32_arr0_ptr)(&main_light)), 1);
  main_darkUniform = tfx_uniform_new("dark", 4, 1);
  tfx_set_uniform((&main_darkUniform), ((nlfloat32_arr0_ptr)(&main_dark)), 1);
  main_intensityUniform = tfx_uniform_new("intensity", 1, 1);
  tfx_set_uniform((&main_intensityUniform), ((nlfloat32_arr0_ptr)(&main_intensity)), 1);
  main_amountUniform = tfx_uniform_new("amount", 1, 1);
  tfx_set_uniform((&main_amountUniform), ((nlfloat32_arr0_ptr)(&main_amount)), 1);
  main_entitylist.v[0] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[1] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[2] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[3] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[4] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[5] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[6] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[7] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[8] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[9] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[10] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[11] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[12] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[13] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[14] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[15] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[16] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[17] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[18] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[19] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[20] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[21] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[22] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[23] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[24] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[25] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[26] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[27] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[28] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[29] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[30] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[31] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[32] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[33] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[34] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[35] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[36] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[37] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[38] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[39] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[40] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[41] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[42] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[43] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[44] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[45] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[46] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[47] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[48] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[49] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[50] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[51] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[52] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[53] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[54] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[55] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[56] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[57] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[58] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[59] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[60] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[61] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[62] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[63] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[64] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[65] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[66] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[67] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[68] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[69] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[70] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[71] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[72] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[73] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[74] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[75] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[76] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[77] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[78] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[79] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[80] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[81] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[82] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[83] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[84] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[85] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[86] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[87] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[88] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[89] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[90] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[91] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[92] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[93] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[94] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[95] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[96] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[97] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[98] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[99] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_entitylist.v[100] = ({
    main_entity _tmp = {0};
    _tmp.x = (double)nelua_math_random_1(0, main_g_width);
    _tmp.y = (double)nelua_math_random_1(0, main_g_height);
    _tmp.vx = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp.vy = (nelua_math_random_2(-100, 100) / (double)900);
    _tmp;
  });
  main_now = SDL_GetPerformanceCounter();
  while(main_running) {
    main_last = main_now;
    main_now = SDL_GetPerformanceCounter();
    main_delta = (((main_now - main_last) * 1000) / (double)SDL_GetPerformanceFrequency());
    SDL_Event event = {0};
    while((SDL_PollEvent((&event)) == 1)) {
      switch(event.type) {
        case 256: {
          main_running = false;
          break;
        }
        case 512: {
          if((event.window.event == 5)) {
            SDL_GL_GetDrawableSize(main_window, (&main_g_width), (&main_g_height));
            tfx_reset((uint16_t)main_g_width, (uint16_t)main_g_height, 14);
            main_projection = libs_math_extra_mat4_from_ortho(0.0, (double)main_g_width, 0.0, (double)main_g_height, -10.0, 10.0);
            tfx_set_uniform((&main_projectionUniform), ((nlfloat32_arr0_ptr)(&(*(nlfloat32_arr16*)main_projection.data))), 1);
          }
          break;
        }
      }
    }
    tfx_view_set_clear_color((uint8_t)main_back, 0x16161bffU);
    tfx_view_set_clear_depth((uint8_t)main_back, 1.0f);
    tfx_view_set_name((uint8_t)main_back, "Forward Pass");
    {
      nlmulret_function_3KD4K8avoExANbbuQ_main_entity_arr101_ptr_nlint64 _asgnret_1 = nelua_mipairs_1((&main_entitylist));
      function_3KD4K8avoExANbbuQ __fornext = _asgnret_1.r1;
      main_entity_arr101_ptr __forstate = _asgnret_1.r2;
      int64_t __forit = _asgnret_1.r3;
      while(true) {
        bool __forcont;
        main_entity_ptr item;
        nlmulret_nlboolean_nlint64_main_entity_ptr _asgnret_2 = __fornext(__forstate, __forit);
        __forcont = _asgnret_2.r1;
        __forit = _asgnret_2.r2;
        item = _asgnret_2.r3;
        if((!__forcont)) {
          break;
        }
        int64_t z = __forit;
        {
          double gray = ((z / (double)101) * 1);
          item->x = (item->x + ((item->vx * main_delta) * gray));
          item->y = (item->y + ((item->vy * main_delta) * gray));
          if(((item->x < 0) || ((item->x + 30) > main_g_width))) {
            item->vx = (-item->vx);
          }
          if(((item->y < 0) || ((item->y + 30) > main_g_height))) {
            item->vy = (-item->vy);
          }
          libs_math_extra_mat4_identity((&main_model));
          main_model = libs_math_extra_mat4_translate(libs_math_extra_mat4_scale(main_model, (libs_math_extra_vec3){.x = 30.0, .y = 30.0, .z = 1.0}), (libs_math_extra_vec3){.x = item->x, .y = item->y, .z = (z / (double)101)});
          tfx_set_uniform((&main_modelUniform), ((nlfloat32_arr0_ptr)(&(*(nlfloat32_arr16*)main_model.data))), 1);
          main_color = (nlfloat32_arr4){{(float)gray, (float)gray, (float)gray, 1.0f}};
          tfx_set_vertices((&main_vbo), 6);
          tfx_set_state(56U);
          tfx_set_uniform((&main_colorUniform), ((nlfloat32_arr0_ptr)(&main_color)), 1);
          tfx_submit((uint8_t)main_back, main_program, false);
        }
      }
    }
    tfx_frame();
    SDL_GL_SwapWindow(main_window);
  }
  { /* defer */
    tfx_shutdown();
  }
  { /* defer */
    SDL_DestroyWindow(main_window);
  }
  { /* defer */
    SDL_Quit();
  }
  return 0;
}
